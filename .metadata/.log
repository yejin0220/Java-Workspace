!SESSION 2022-11-11 15:00:06.660 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product -data C:\Java-Workspace\Java-Workspace -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-11 15:00:08.202
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-11 15:00:09.405
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-11 15:00:09.405
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69af938b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cb87009,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-11 15:00:16.627
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-14 08:55:28.242 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 08:55:38.053
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-14 08:55:42.544
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-14 08:55:42.544
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@258ac1e6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@491f3fb0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-14 08:55:50.358
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-11-14 12:43:53.053
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chop2.loop;

public class B_While {
	
	/*
	 * while문
	 * [표기법]
	 * 
	 * [초기식;] //필수가 아님 
	 * while(조건식) { //조건이 thue일 경우 해당구문들을 반복적으로 실행, 조건식 내용에 true를 작성시 무한 반복함
	 *        반복적으로 실행할 코드
	 *        [증감식]; //필수는 아님
	 * }
	 * 
	 * 
	 * for문과 다르게 초기식, 증감식이 필수가 아님
	 * 
	 * 분기문에서 초기식, 증감식없이 작성하는 법을 배울 예정
	 * 
	 * 
	 * 
	 * 
	 * 
	 */

	public void method1( ) {
		
		//for문을 while문으로, while문을 for문으로 표현할 수 있음
		
		//[for]문
		for(int i = 0; i<5; i++) {
			System.out.println("안녕하세요.");
		}
		
		
		//[while]문
		int i = 0; //초기식 작성
		while(i<5) { //조건식 작성
			System.out.println("안녕하세요.");
			i++;//증감식 작성
		}
		
		
		System.out.println("i : "+i);  //=> while문에서 처리된 i의 값은 5 => 4까지 증감되었을때는 true로 문장이 출력됨
		                                                             //5까지 증감된 후 false가 나오기 때문에 while문 벗어남
		                                                            //최종값은 5
		
		
		
		
		
		
	}
	
	
	
	public void method2( ) {
		//1~10사이의 정수중 홀수만 출력하시요
		
		//1.for
		for(int i = 1; i<=10; i++) {
			if(i%2 != 0){
			System.out.print(i+ " ");
		}
		}
		
		
		
//		for(int i = 1; i<=0; i+=2) {
//			System.out.print(i+" ");
//		}
		
		
		
		
		System.out.println();
		
		//while
//		int i =1;
//		while(i<=10) {
//					
//			if(i%2 != 0) {
//				 System.out.print(i+" ");
//				
//			}
//			i++;
//		}
		
		int i =1;
		while(i<=10) {
			System.out.print(i+" ");
			i+=2;
		}
		
		
	}
	
	
	public void method3( ) {
		
		//1부터 랜덤값(1~100이하)까지의 총 합계를 구하여라
		
		(Math.random()*100+1)
		//0.0 <= 랜덤값 < 100.0
		//1.0 <= 랜덥값 <101
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-11-14 12:43:53.055
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-11-14 12:43:53.055
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-14 12:43:53.206
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chop2.loop;

public class B_While {
	
	/*
	 * while문
	 * [표기법]
	 * 
	 * [초기식;] //필수가 아님 
	 * while(조건식) { //조건이 thue일 경우 해당구문들을 반복적으로 실행, 조건식 내용에 true를 작성시 무한 반복함
	 *        반복적으로 실행할 코드
	 *        [증감식]; //필수는 아님
	 * }
	 * 
	 * 
	 * for문과 다르게 초기식, 증감식이 필수가 아님
	 * 
	 * 분기문에서 초기식, 증감식없이 작성하는 법을 배울 예정
	 * 
	 * 
	 * 
	 * 
	 * 
	 */

	public void method1( ) {
		
		//for문을 while문으로, while문을 for문으로 표현할 수 있음
		
		//[for]문
		for(int i = 0; i<5; i++) {
			System.out.println("안녕하세요.");
		}
		
		
		//[while]문
		int i = 0; //초기식 작성
		while(i<5) { //조건식 작성
			System.out.println("안녕하세요.");
			i++;//증감식 작성
		}
		
		
		System.out.println("i : "+i);  //=> while문에서 처리된 i의 값은 5 => 4까지 증감되었을때는 true로 문장이 출력됨
		                                                             //5까지 증감된 후 false가 나오기 때문에 while문 벗어남
		                                                            //최종값은 5
		
		
		
		
		
		
	}
	
	
	
	public void method2( ) {
		//1~10사이의 정수중 홀수만 출력하시요
		
		//1.for
		for(int i = 1; i<=10; i++) {
			if(i%2 != 0){
			System.out.print(i+ " ");
		}
		}
		
		
		
//		for(int i = 1; i<=0; i+=2) {
//			System.out.print(i+" ");
//		}
		
		
		
		
		System.out.println();
		
		//while
//		int i =1;
//		while(i<=10) {
//					
//			if(i%2 != 0) {
//				 System.out.print(i+" ");
//				
//			}
//			i++;
//		}
		
		int i =1;
		while(i<=10) {
			System.out.print(i+" ");
			i+=2;
		}
		
		
	}
	
	
	public void method3( ) {
		
		//1부터 랜덤값(1~100이하)까지의 총 합계를 구하여라
		
		(Math.random()*100+1)
		//0.0 <= 랜덤값 < 100.0
		//1.0 <= 랜덥값 <101
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-14 12:43:53.207
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-14 12:43:53.207
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-14 12:44:01.069
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chop2.loop;

public class B_While {
	
	/*
	 * while문
	 * [표기법]
	 * 
	 * [초기식;] //필수가 아님 
	 * while(조건식) { //조건이 thue일 경우 해당구문들을 반복적으로 실행, 조건식 내용에 true를 작성시 무한 반복함
	 *        반복적으로 실행할 코드
	 *        [증감식]; //필수는 아님
	 * }
	 * 
	 * 
	 * for문과 다르게 초기식, 증감식이 필수가 아님
	 * 
	 * 분기문에서 초기식, 증감식없이 작성하는 법을 배울 예정
	 * 
	 * 
	 * 
	 * 
	 * 
	 */

	public void method1( ) {
		
		//for문을 while문으로, while문을 for문으로 표현할 수 있음
		
		//[for]문
		for(int i = 0; i<5; i++) {
			System.out.println("안녕하세요.");
		}
		
		
		//[while]문
		int i = 0; //초기식 작성
		while(i<5) { //조건식 작성
			System.out.println("안녕하세요.");
			i++;//증감식 작성
		}
		
		
		System.out.println("i : "+i);  //=> while문에서 처리된 i의 값은 5 => 4까지 증감되었을때는 true로 문장이 출력됨
		                                                             //5까지 증감된 후 false가 나오기 때문에 while문 벗어남
		                                                            //최종값은 5
		
		
		
		
		
		
	}
	
	
	
	public void method2( ) {
		//1~10사이의 정수중 홀수만 출력하시요
		
		//1.for
		for(int i = 1; i<=10; i++) {
			if(i%2 != 0){
			System.out.print(i+ " ");
		}
		}
		
		
		
//		for(int i = 1; i<=0; i+=2) {
//			System.out.print(i+" ");
//		}
		
		
		
		
		System.out.println();
		
		//while
//		int i =1;
//		while(i<=10) {
//					
//			if(i%2 != 0) {
//				 System.out.print(i+" ");
//				
//			}
//			i++;
//		}
		
		int i =1;
		while(i<=10) {
			System.out.print(i+" ");
			i+=2;
		}
		
		
	}
	
	
	public void method3( ) {
		
		//1부터 랜덤값(1~100이하)까지의 총 합계를 구하여라
		
		int rand(Math.random()*100+1)
		//0.0 <= 랜덤값 < 100.0
		//1.0 <= 랜덥값 <101
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-11-14 12:44:01.070
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-11-14 12:44:01.070
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-14 14:35:43.295
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chap03.branch;

public class A_Break {

	/*
	 * break; : break문을 만나는 순간 현재 속해있는 반복문을 빠져나감.
	 * -> 즉, 가장 가까운 반복문만 빠져나감
	 * 
	 * 주의할 점 : switch문 안의 break와는 다른 개념
	 *           switch문 안의 break는 해당 switch문만 빠져나가는 용도.
	 *           
	 * 
	 * 
	 */
	
	public void methid1() {
	 //매번 반복적으로 발생되는 랜덤값(1~100) 출력
	//그 랜던값이 3의 배수일 경우에만 반복문을 종료
		
		while(true) {
			//랜덤값 뽑아오기
			(Math.random()*100+1)
			//랜덤값 출력
			//랜덥값이 3의 배수인지 검사.
		}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
 }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-11-14 14:35:43.296
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-11-14 14:35:43.296
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-14 14:35:43.300
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chap03.branch;

public class A_Break {

	/*
	 * break; : break문을 만나는 순간 현재 속해있는 반복문을 빠져나감.
	 * -> 즉, 가장 가까운 반복문만 빠져나감
	 * 
	 * 주의할 점 : switch문 안의 break와는 다른 개념
	 *           switch문 안의 break는 해당 switch문만 빠져나가는 용도.
	 *           
	 * 
	 * 
	 */
	
	public void methid1() {
	 //매번 반복적으로 발생되는 랜덤값(1~100) 출력
	//그 랜던값이 3의 배수일 경우에만 반복문을 종료
		
		while(true) {
			//랜덤값 뽑아오기
			(Math.random()*100+1)
			//랜덤값 출력
			//랜덥값이 3의 배수인지 검사.
		}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
 }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-14 14:35:43.300
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-14 14:35:43.301
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-14 14:35:44.300
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chap03.branch;

public class A_Break {

	/*
	 * break; : break문을 만나는 순간 현재 속해있는 반복문을 빠져나감.
	 * -> 즉, 가장 가까운 반복문만 빠져나감
	 * 
	 * 주의할 점 : switch문 안의 break와는 다른 개념
	 *           switch문 안의 break는 해당 switch문만 빠져나가는 용도.
	 *           
	 * 
	 * 
	 */
	
	public void methid1() {
	 //매번 반복적으로 발생되는 랜덤값(1~100) 출력
	//그 랜던값이 3의 배수일 경우에만 반복문을 종료
		
		while(true) {
			//랜덤값 뽑아오기
			((Math.random()*100+1)
			//랜덤값 출력
			//랜덥값이 3의 배수인지 검사.
		}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
 }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-11-14 14:35:44.301
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-11-14 14:35:44.301
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-14 14:35:46.806
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chap03.branch;

public class A_Break {

	/*
	 * break; : break문을 만나는 순간 현재 속해있는 반복문을 빠져나감.
	 * -> 즉, 가장 가까운 반복문만 빠져나감
	 * 
	 * 주의할 점 : switch문 안의 break와는 다른 개념
	 *           switch문 안의 break는 해당 switch문만 빠져나가는 용도.
	 *           
	 * 
	 * 
	 */
	
	public void methid1() {
	 //매번 반복적으로 발생되는 랜덤값(1~100) 출력
	//그 랜던값이 3의 배수일 경우에만 반복문을 종료
		
		while(true) {
			//랜덤값 뽑아오기
			(int(Math.random()*100+1)
			//랜덤값 출력
			//랜덥값이 3의 배수인지 검사.
		}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
 }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-11-14 14:35:46.807
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-11-14 14:35:46.807
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-14 14:35:47.146
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chap03.branch;

public class A_Break {

	/*
	 * break; : break문을 만나는 순간 현재 속해있는 반복문을 빠져나감.
	 * -> 즉, 가장 가까운 반복문만 빠져나감
	 * 
	 * 주의할 점 : switch문 안의 break와는 다른 개념
	 *           switch문 안의 break는 해당 switch문만 빠져나가는 용도.
	 *           
	 * 
	 * 
	 */
	
	public void methid1() {
	 //매번 반복적으로 발생되는 랜덤값(1~100) 출력
	//그 랜던값이 3의 배수일 경우에만 반복문을 종료
		
		while(true) {
			//랜덤값 뽑아오기
			(int(Math.random()*100+1)
			//랜덤값 출력
			//랜덥값이 3의 배수인지 검사.
		}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
 }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-14 14:35:47.147
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-14 14:35:47.147
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3401)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-14 14:54:09.897
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chap03.branch;

import java.util.Scanner;

public class A_Break {

	/*
	 * break; : break문을 만나는 순간 현재 속해있는 반복문을 빠져나감.
	 * -> 즉, 가장 가까운 반복문만 빠져나감
	 * 
	 * 주의할 점 : switch문 안의 break와는 다른 개념
	 *           switch문 안의 break는 해당 switch문만 빠져나가는 용도.
	 *           
	 * 
	 * 
	 */
	
	public void methid1() {
	 //매번 반복적으로 발생되는 랜덤값(1~100) 출력
	//그 랜던값이 3의 배수일 경우에만 반복문을 종료
		
		while(true) {
			//랜덤값 뽑아오기
			int random =(int)(Math.random()*100+1);
			
			//랜덤값 출력
			System.out.println("random : "+random);
			//랜덥값이 3의 배수인지 검사.
			if(random%3==0){    //케이스에 따라서 한 번만 추출될 수도 있고, 여러번 추출될 수도 있음.
				break;   
			}
		}
	 
	 
 }
	
	public void methid2() {
		
		//매번 사용자에게 문자열을 입력 받은 후, 해당 문자열의 길이를 출력하라. => 무한반복문 , 입력유도문을 while밖에 입력하면 매번 반복이 안됨.-> 안에 입력
		//단, 사용자가 입력한 문자열이 "exit"인 경우 반복문을 종료.
		
		
		Scanner sc = new Scanner(System.in);
		
		//문자열의 경우 동등비교 연산이 불가능 하기 때문에 반드시!!! str.equals("") 메소드를 사용해줘야 함.
		
		
		while(true) {
			System.out.print("문자열 입력 : ");     //매번 사용자에게 입력받기 때문에 while문 안에 입력해야함.
			String str = sc.nextLine();
			
			if(str.equals("exit")) {    //사용자가 입력한 문자열이 exit인경우 반복문 종료
				break;
			}
			
			System.out.println(str+"의 길이는 : "+str.length());
		}
		
		
		
		
		
	}
	
	
	public void methid3()  {
		//매번 반복적으로 사용자에게 양수를 입력 받아 1~사용자가 입력한 수까지 출력
		//다만 정상적으로 양수를 입력했을 시, 1~사용자가 입력한 수까지 출력을 하고 종료.
		
		
		
		Scanner sc = new Scanner(System.in);
		
		while(true) {
			System.out.print("양수입력 : ");
			int num = sc.nextInt();
			
			if(num>0) { //양수로 제대로 입력한 경우 ->1 부터 num까지 출력 후 종료.
				for(int i =1; i<=num;i++) {
					System.out.print(i+" ");
				}
			}
			break;
		} else(num<) {//잘못 입력시 -> 다시 입력하라는 출력문 ->
			System.out.println("잘못입력했습니다. 다시 입력하세요.");
		}
	
		
		
		
		
	}
	
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-14 14:54:09.897
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-14 14:54:09.897
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-11-14 15:01:08.902 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:01:15.056
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-14 15:01:17.359
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-14 15:01:17.359
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2e73ce,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3891db3a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-14 15:01:22.639
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-14 15:10:13.634 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.086
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:10:17.102
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-14 15:10:17.956
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-14 15:10:17.956
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a778943,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7925e772,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-14 15:10:22.330
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-14 15:13:59.380 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.924
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-14 15:14:15.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-14 15:14:16.807
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-14 15:14:16.807
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@134ec0f3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@258ac1e6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-14 15:14:21.107
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-15 08:59:14.332 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-15 08:59:27.353
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-15 08:59:30.789
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-15 08:59:30.789
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@491f3fb0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3d0ce151,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-15 08:59:38.767
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:41.290
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = random;
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-11-15 12:40:41.292
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-11-15 12:40:41.292
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:41.407
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = random;
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:41.410
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:41.412
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:42.490
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = random;
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor45.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:42.491
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor45.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:42.492
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor45.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:42.629
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = random;
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:42.630
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:42.631
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:45.304
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-11-15 12:40:45.304
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-11-15 12:40:45.304
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:45.311
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:45.312
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:45.312
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:47.092
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:47.092
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:47.093
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:48.967
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:48.967
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:48.968
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:51.300
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:51.301
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:51.301
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:57.883
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:57.884
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:57.884
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:57.888
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:57.888
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:57.889
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:57.893
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:57.893
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:57.894
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:57.898
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:57.898
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:57.899
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:57.903
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:57.903
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:57.904
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:57.908
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:57.909
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:57.909
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:57.913
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:57.914
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:57.914
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:57.918
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:40:57.919
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:40:57.919
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:40:58.324
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-11-15 12:40:58.325
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-11-15 12:40:58.326
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:41:01.255
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:41:01.256
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:41:01.256
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:41:01.260
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1022)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-15 12:41:01.261
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1022)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-15 12:41:01.280
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.array;



public class A_arry {

	/*
	 * 변수 : 하나의 공간에 하나의 값을 담을 수 있음
	 *        ex) int a= 10;
	 *            a = 20 ; -> 10이라는 값은 사라짐
	 *           
	 * 배열 : 하나의 공간에 여러개의 값을 담을 수 있음 (단, 같은 자료형의 값으로만 가능)
	 *       정확히 말하자면, 배열의 각 인덱스 자리에 실제값이 담김(인덱스 0 부터 시작)
	 *       예) int[] a = new int[3]  => int형의 자료가 들어갈 수 있는 공간을 3개 만든다.
	 *                                => 방, 사물함 [0] [1] [2]을 3개 만듬/ 이곳에 int값을 저장
	 *                                => 인덱스는 항상 0부터 시작한다.(중요!)
	 *                                => 배열의 크기 : 3 / 마지막 인덱스 : 2
	 *                                => 만약 배열의 크기가 100이라면? 마지막 인덱스는 99
	 *                                => 항상! 배열의 크기가 n이라면? 마지막 인덱스는 (n-1)
	 *           
	 * 
	 * 
	 */
	
	
	
	
	
	
	
	
	public void method1() {
		// 배열을 왜 써야할까?
		// 만약, 변수만을 가지고 프로그래밍을 하게 되면
		// 0, 1,2, 3, 4 라는 숫자를 각각 기록 할ㄸ때?
		
		/*
		 * 변수를 이용하여 각각의 데이터를 보관하고자 할때 => 각각의 정수값을 각각의 변수를 만들어서 따로 관리해야함
		 * 
		 * int num = 0;
		 * int num1 = 1;
		 * int num2 = 2;
		 * int num3 = 3;
		 * int num4 = 4;
		 * 
		 * 출력시 일일이 출력해야하고 반복문 사용이 안됨
		 * 
		 * 
		 * 
		 * for(int i = 1; i<=5; i++){
		 *    System.out.println(num+i);     => 실행 안됨
		 *    }
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 배열 사용시
		 * 1. 배열을 가지고 프로그래밍 하기
		 * 0. 1 2 3 의 데이터를 저장해야한다
		 * 
		 * 1) 배열선언방법
		 * [표현법]
		 * 자료형 [] 배열명;
		 * 자료형 배열명 [];
		 * int a; => 변수
		 * int [] a; => 배열
		 * int a []; => 배열
		 * 자료형의 값은 고정!
		 * 
		 * 
		 * 
		 * 2) 배열 할당
		 * 이 배열에 몇 개의 값들을 보관할건지, 배열의 크기를 지정해주는 과정
		 * 지정한 객수만큼 값이 들어갈 방이 생성됨.
		 * 
		 * [표현법]
		 * 배열명 = new 자료형[배열의 크기]
		 * ex) a = new int[5] 
		 * 
		 */
		
		int [] arr = new int[5]; //기본적으로 stak영역에 int[]arr이라는 값이 저장됨
		                         //new를 선언하면 heap영역에 배열의 크기만큼 값이 할당됨(데이터 값이 저장됨)
		                         //값을 설정하지 않는다면 0으로 초기화 되어 저장됨
		
		//System.out.println(arr[0]);
		
		
		/*
		 * 3. 배열의 각 인덱스(=방번호) 자리에 값 대임
		 * 
		 * [표현법]
		 * 배열명[인덱스] = 값;
		 * 
		 * arr[0] = 0;
		 * arr[1] = 1;
		 * arr[2] = 2;
		 * arr[3] = 3;
		 * arr[4] = 4;
		 * 
		 */
		
		
		//배열의 가장 큰 장점 : 반복문을 활용할 수 있다.
	
		for(int i = 0; i<5; i++) {
			//0 1 2 3 4 
			arr[i] = i;       
		}
		
		
		//배열의 for문을 활용해 값을 입력, 출력도 가능함
		for(int i = 0; i<5; i++) {
			System.out.printf("%d번 인덱스의 값은 : %d \n", i,arr[i]); 
		}
		
		
		//각각의 인덱스 값을 확인하기 위해서는 []블럭을 통해 내가 확인하고자 하는 인덱스(방번호)를 제시해줘야함.
		//만약 arr에 담겨있는 전체 값을 확인하고 싶다면?
		System.out.println(arr);  //  => [I@1888ff2c 실제 arr이 heap에 저장되어 있는 주소값
		                         //실제 배열(arr)이라는 값에는 주소값이 담겨져 있음
		                         //@를 기준으로 우측은 참조하고 있는 heap영역의 주소값
		                        // [ : 배열을 의미
		                        //I : int자료형을 의미

		
		
	}
	
	
	
	
	public void method2() {
		
		int i = 10; //일반 변수, stack영역에 i는 10이라는 값이 그냥 담겨있음.
		
		int [] arr = new int [5]; // 배열 자료형// 5칸짜리 배열이 방이 생성되고 그 안에 0으로 값이 할당되어 있음
		
		/*
		 * 우선 대입 연산자 기준 왼쪽이 먼저 실행되므로 arr이라는 int형 배열 박스가 먼저 만들어짐(stack영역에)
		 * 그 다음 int[5] (5칸 짜리)방이 heap영역에 생성됨(new라는 키워드가 붙은 녀석은 heap영역에 값이 할당됨)
		 * 5칸 짜리 방이 만들어진 후에 각 방에 기본값으로(int 0)으로 데이터가 초기화 되고, 주소값이 할당됨(0x123)
		 * 마지막으로 대입연산자가 실행되면서 주소값이 arr에 할당됨
		 * 
		 * 
		 * 
		 */
		
		System.out.println("i : "+i);
		System.out.println("arr :"+arr);  //본인의 주소값 그대로 출력
		System.out.println("arr의 해시코드 값 : "+arr.hashCode()); 
		//해시코드 : 주소값을 10진수의 형태로 변환해준 것 
		
		
		double[] dArr = new double[3];  //drr에는 new double의 고유한 주소값이 출력
		System.out.println(dArr);
		System.out.println("dArr의 해코드값 : "+dArr.hashCode());
		
		
		/*
		 * 기본자료형(boolean, char, sbyte, short, int, long, float, doubld)
		 * =>실제 값(리터럴)을 바로 stack영역에 담을 수 있는 변수 => 일반 변수
		 * 
		 * 그 외 자료형(int[], double[]. short[] ....,String, Scanner, ....그외 클래스 모두)
		 * =>실제 주소값을 담고 있는 변수 => 참조 변수(레퍼런스 변수)
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	public void method3() {
		
		int [] iArr = new int[3];  //iArr의 모든 인덱스는 0으로 초기화 되어 있음.
		
		double []  dArr = new double[3];
		
		
		for(int i = 0; i < iArr.length; i++) { //iArr의  길이까지를 출력
			System.out.println(iArr[i]);//iArr에 담겨있는 각 인덱스의 값을 출력
		}
		
		
		
		for(int i = 0; i<dArr.length; i++) {
			System.out.println(dArr[i]);
		}
		
		
		
		/*
		 * 내가 각 인덱스를 초기화 하지 않았는데도 0이라는 값들이 담겨져있는 이유?
		 * -> heap이라는 영역에는 절대로 빈공간이 존재할 수 없음
		 * -> 따라서 jvm이 각 공간에 각 자료형의 기본값으로 초기화(대입)을 시켜줌.
		 * -> heap영역에 담기는 자료형들은 jvm이 자동으로 기본값을 대입
		 * int 는 0으로, doubld은 0.0으로....
		 * 
		 * 배열의 크기를 아는 방법 : 배열명,lenght
		 * 
		 *
		 */
		
		
		
		
		
		
		
	}
	
	
	
	
	
	public void method4() {
		
		int[] arr = new int[5];
		
		//각 배열의 인덱스에다가 값을 대입하는 반복문 마들기
		for(int i = 0; i<arr.length;i++) { 
			arr[i] = i+1; // arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5 모든 방에 접근해 값을 대입할 수 있음
			
		} System.out.println(arr[4]); //-> 마지막 인덱스에 입력되어 있는 값은?
		                               //마지막 인덱스의 숫자는 길이-1 : arr의 크기(길이는) 5이고, 마지막 인덱스의 값은 길이-1이므로 4가 출력
		/*
		 * 가장 많이 보이는 오류
		 * 
		 * ArrayIndexOutOfBoundExecption 
		 * 배열의 인덱스를 벗어나서 생기는 오류
		 * 따라서 해당 인덱스 안에 있는 값으로 인덱스를 설정해줘야 함
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method5() { 
		
		int i = 0;
		String str = null;
		
		// int i2 = null; -> typeMissMath : null값을 int자료형에 넣을 수 없음
		
		int[]arr = null; // null값을 할당할 수 있음
		                 //주소값을 담을 수 있는 변수의 기본값은 null;
		                 //int형 배열을 null값으로 초기화 시킴
		
	
		//System.out.println(arr.hashCode()); //int자료형에 null값이 대입되어 있는것이지 heap영역에 주소가 생성된게 아니기 때문에 주소값을 가져올 수가 없음
		/*
		 * => 무조건 오류가발생
		 * 기본값이 null인 변수를 가지고 메소드를 호출한다거나, 특정 어딘가에 접근하고자 한다면 무조건 오류발생
		 * ->NullPointerException
		 * ex)arr.hashCode(), arr.leght() 등
		 * 
		 * 
		 */
		
		
		
		
		
	}
	
	
	public void method6() {
		
		int [] arr = new int[5]; //크기가 5인 int형 배열 선언
		
				/*반복문 활용
				 * arr[0]=2
				 * arr[1]=4
				 * arr[2]=6
				 * arr[3]=8
				 * arr[4]=10
				 * 
				 */
		
				for(int i =0; i<arr.length; i++) { 
					arr[i]= i+(i+2);
				}
				for(int i =0; i<arr.length; i++) {
					System.out.println(arr[i]);
				}
					
		//System.out.println(arr[5]);
			//arr[6] = 100;
			/*
			 * 배열의 가장 큰 단점
			 * 한번 지정한 배열의 크기는 변경 불가능 함
			 * => 배열의 크기를 변경하고자 한다면, 새롱ㄴ 배열을 다시 만들어야함.
			 * 
			 */
			
			
			
			System.out.println("================arr변경전================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());

		
			arr = new int[7];
			System.out.println("================arr변경후================");
			System.out.println(arr);
			System.out.println("arr의 해시코드 값 : "+arr.hashCode());
			/*
			 * 항상 고유한 주소값 부여, 기존에 생성되었던 주소와 절대로! 겹치지 않는다.
			 * 기존에 참조하고 있던 연결이 끊기고 새로운 곳 참조
			 * 
			 * 연결이 끊어진 기존의 배열은 heap영역에 둥둥 떠다님
			 * 일정 시간이 지나고서도 사용이 되지 않으면 "가비지컬렉터(GC)"가 삭제시켜 줌 => 자동메모리 관리
			 * 
			 * [자동메모리관리]
			 * -자바에서의 특징 : 개발자가 코드에만 신경쓸 수 있게 해줌
			 * 
			 * 
			 */
			
			
			
			//현재 연결되어 있는 고리를 끊고자 할때
			arr= null; //null : 아무것도 존재하지 않음을 의미
			

	}
	
	public void method7() {
		
		//1)배열을 선언과 동시에 할당하기(크기 지정
		int[] arr = new int[4];
		
		//2)각 인덱스에 값을 초기화(대입)
		arr [0] = 1;
		arr [1] = 2;
		arr [2] = 3;
		arr [3] = 4;
	
		
		//배열 선언 및 동시에 초기화(대입) 까지 한 번에 끝내는 방법2가지
		//방법.1
		int [] arr1 = new int[] {1, 2, 3, 4}; //arr1은 크기가 4인 배열이 생성되어 있고 각 인덱스 안에 1,2,3,4 값이 저장되어 있음
		
		//방법.2(조금 더 단순화)
		int [] arr2 = {1, 2, 3, 4 }; //arr1은 크기가 4인 배열안에 1,2,3,4 값이 저장되어 있음
		
		
		//동등비교
		System.out.println(arr1==arr2); //false
		//arr1 : arr1의 heap영역의 "주소값"
		//arr2 : arr2의 heap영역의 "주소값"
		//즉, 주소값 == 주소값 : 주소값 간의 동등비교를 수행하기 때문에 결과는 무조건 false
		//각 배열이 가지는 주소는 모두 고유한 각자의 주소를 가지고 있다.
		
		
		
	}
	
	public void method8() {
		//1. 크기 10짜리 정수 int형 배열 선언
		//2. 반복문을 활용해서 0번 인덱스 부터 마지막 인덱스 까지 순차적으로 접근하기
		//3. 값을 대입 : 랜덤값으로(1~100)
		//4. 반복문을 활용해서 0~마지막 인덱스 까지 배열에 담긴 값 출력하기
		//5. 출력예시 : arr[x] : xx
		
		
		
	//1. 크기 10짜리 정수 int형 배열 선언
		int [] arr = new int[10];
		
		//랜덤값 1~100
		
		(Math.random()*100+1);
		
		for(int i = 0; i<arr.length ; i++) {
			arr[i] = (Math.random()*100+1);
		}
		for(int i = 0 ; i<arr.length ; i++) {
			System.out.printf("arr[%d] : %d \n",i, arr[i]);
		}
		
		
		
		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-15 12:41:01.281
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-15 12:41:01.282
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-11-16 08:55:25.882 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 08:55:38.754
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-16 08:55:45.568
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-16 08:55:45.568
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76efa2b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2027d56f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-16 08:55:55.971
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.760
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.graphics.Image.createGdipImage(Image.java:990)
	at org.eclipse.swt.graphics.GC.drawImage(GC.java:946)
	at org.eclipse.swt.graphics.GC.drawImageInPixels(GC.java:873)
	at org.eclipse.swt.graphics.GC.drawImage(GC.java:866)
	at org.eclipse.swt.custom.CTabFolderRenderer.drawSelected(CTabFolderRenderer.java:1447)
	at org.eclipse.swt.custom.CTabFolderRenderer.draw(CTabFolderRenderer.java:637)
	at org.eclipse.e4.ui.workbench.renderers.swt.CTabRendering.draw(CTabRendering.java:280)
	at org.eclipse.swt.custom.CTabFolder.onPaint(CTabFolder.java:2088)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:336)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1525)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.762
!MESSAGE Error occurred during status handling
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Display.error(Display.java:1246)
	at org.eclipse.swt.widgets.Display.internal_new_GC(Display.java:2664)
	at org.eclipse.swt.graphics.Device.getDepth(Device.java:477)
	at org.eclipse.swt.widgets.Display.getIconDepth(Display.java:1889)
	at org.eclipse.swt.widgets.Decorations.setImages(Decorations.java:893)
	at org.eclipse.swt.widgets.Decorations.setImages(Decorations.java:981)
	at org.eclipse.jface.window.Window.configureShell(Window.java:373)
	at org.eclipse.ui.internal.statushandlers.InternalDialog.configureShell(InternalDialog.java:191)
	at org.eclipse.jface.window.Window.createShell(Window.java:498)
	at org.eclipse.jface.window.Window.create(Window.java:430)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ui.internal.statushandlers.WorkbenchStatusDialogManagerImpl.doAddStatusAdapter(WorkbenchStatusDialogManagerImpl.java:247)
	at org.eclipse.ui.internal.statushandlers.WorkbenchStatusDialogManagerImpl.addStatusAdapter(WorkbenchStatusDialogManagerImpl.java:188)
	at org.eclipse.ui.statushandlers.WorkbenchStatusDialogManager.addStatusAdapter(WorkbenchStatusDialogManager.java:152)
	at org.eclipse.ui.statushandlers.WorkbenchErrorHandler.showStatusAdapter(WorkbenchErrorHandler.java:79)
	at org.eclipse.ui.statushandlers.WorkbenchErrorHandler.handle(WorkbenchErrorHandler.java:52)
	at org.eclipse.ui.internal.ide.IDEWorkbenchErrorHandler.handle(IDEWorkbenchErrorHandler.java:104)
	at org.eclipse.ui.internal.WorkbenchErrorHandlerProxy.handle(WorkbenchErrorHandlerProxy.java:34)
	at org.eclipse.ui.statushandlers.StatusManager.handle(StatusManager.java:217)
	at org.eclipse.ui.statushandlers.StatusManager.handle(StatusManager.java:259)
	at org.eclipse.ui.statushandlers.StatusManager.handle(StatusManager.java:269)
	at org.eclipse.ui.application.WorkbenchAdvisor.eventLoopException(WorkbenchAdvisor.java:304)
	at org.eclipse.ui.internal.Workbench$1.eventLoopException(Workbench.java:484)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.handle(PartRenderingEngine.java:1177)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1167)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.764
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.765
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.766
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.767
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.768
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.769
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.769
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.770
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.771
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.772
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.773
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.774
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.775
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.equinox.event 4 0 2022-11-16 14:40:08.777
!MESSAGE Exception while dispatching event org.osgi.service.event.Event [topic=org/eclipse/e4/ui/model/application/ApplicationElement/tags/ADD] {ChangedElement=org.eclipse.ui.views.ProblemView=org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl@3bcedb06 (tags: [View, categoryTag:General, busy], contributorURI: null) (widget: ContributedPartRenderer$1 {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer@3c62bae5, toBeRendered: true, onTop: false, visible: true, containerData: null, accessibilityPhrase: null) (contributionURI: bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView, object: CompatibilityPart [partId=org.eclipse.ui.views.ProblemView, properties=[], tags=[View, categoryTag:General, busy], wrapped=class org.eclipse.ui.internal.views.markers.ProblemsView, legacyPart=class org.eclipse.ui.internal.views.markers.ProblemsView, beingDisposed=false, alreadyDisposed=false], context: PartImpl (org.eclipse.ui.views.ProblemView) Context, variables: [], label: Problems, iconURI: platform:/plugin/org.eclipse.ui.ide/icons/full/eview16/problems_view.png, tooltip: , dirty: false, closeable: true, description: null), org.eclipse.e4.data={ChangedElement=org.eclipse.ui.views.ProblemView=org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl@3bcedb06 (tags: [View, categoryTag:General, busy], contributorURI: null) (widget: ContributedPartRenderer$1 {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer@3c62bae5, toBeRendered: true, onTop: false, visible: true, containerData: null, accessibilityPhrase: null) (contributionURI: bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView, object: CompatibilityPart [partId=org.eclipse.ui.views.ProblemView, properties=[], tags=[View, categoryTag:General, busy], wrapped=class org.eclipse.ui.internal.views.markers.ProblemsView, legacyPart=class org.eclipse.ui.internal.views.markers.ProblemsView, beingDisposed=false, alreadyDisposed=false], context: PartImpl (org.eclipse.ui.views.ProblemView) Context, variables: [], label: Problems, iconURI: platform:/plugin/org.eclipse.ui.ide/icons/full/eview16/problems_view.png, tooltip: , dirty: false, closeable: true, description: null), AttName=tags, EventType=ADD, Position=2, Widget=ContributedPartRenderer$1 {}, NewValue=busy}, AttName=tags, EventType=ADD, Position=2, Widget=ContributedPartRenderer$1 {}, NewValue=busy} to handler org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler@51aa67a5
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Display.error(Display.java:1246)
	at org.eclipse.swt.widgets.Display.internal_new_GC(Display.java:2664)
	at org.eclipse.swt.graphics.Device.getDepth(Device.java:477)
	at org.eclipse.swt.custom.CTabFolder.setBackground(CTabFolder.java:2428)
	at org.eclipse.e4.ui.css.swt.properties.custom.CSSPropertyUnselectedTabsSWTHandler.applyCSSProperty(CSSPropertyUnselectedTabsSWTHandler.java:69)
	at org.eclipse.e4.ui.css.swt.properties.AbstractCSSPropertySWTHandler.applyCSSProperty(AbstractCSSPropertySWTHandler.java:35)
	at org.eclipse.e4.ui.css.core.impl.engine.AbstractCSSEngine.applyCSSProperty(AbstractCSSEngine.java:746)
	at org.eclipse.e4.ui.css.core.impl.engine.AbstractCSSEngine.applyStyleDeclaration(AbstractCSSEngine.java:552)
	at org.eclipse.e4.ui.css.core.impl.engine.AbstractCSSEngine.applyStyles(AbstractCSSEngine.java:419)
	at org.eclipse.e4.ui.css.core.impl.engine.AbstractCSSEngine.applyStyles(AbstractCSSEngine.java:374)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.reapplyStyles(SWTPartRenderer.java:120)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$TabStateHandler.handleEvent(StackRenderer.java:1679)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.subscribeTopicTagsChanged(StackRenderer.java:257)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4725)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:304)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.ui.internal.progress.WorkbenchSiteProgressService.showBusy(WorkbenchSiteProgressService.java:363)
	at org.eclipse.ui.internal.progress.WorkbenchSiteProgressService$SiteUpdateJob.runInUIThread(WorkbenchSiteProgressService.java:120)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.780
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.win32_new(GC.java:5018)
	at org.eclipse.swt.widgets.Composite.WM_PAINT(Composite.java:1537)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4816)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4921)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.781
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTError: No more handles)
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:171)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:135)
	at org.eclipse.jface.text.source.OverviewRuler.redraw(OverviewRuler.java:907)
	at org.eclipse.jface.text.source.OverviewRuler.lambda$0(OverviewRuler.java:488)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.781
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTError: No more handles)
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:171)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:135)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.redraw(AnnotationRulerColumn.java:834)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.782
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTError: No more handles)
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:171)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:135)
	at org.eclipse.jface.text.source.OverviewRuler.redraw(OverviewRuler.java:907)
	at org.eclipse.jface.text.source.OverviewRuler.access$1(OverviewRuler.java:899)
	at org.eclipse.jface.text.source.OverviewRuler$InternalListener.textChanged(OverviewRuler.java:86)
	at org.eclipse.jface.text.TextViewer.updateTextListeners(TextViewer.java:2709)
	at org.eclipse.jface.text.TextViewer.invalidateTextPresentation(TextViewer.java:3353)
	at org.eclipse.jface.text.source.AnnotationPainter.invalidateTextPresentation(AnnotationPainter.java:970)
	at org.eclipse.jface.text.source.AnnotationPainter.updatePainting(AnnotationPainter.java:952)
	at org.eclipse.jface.text.source.AnnotationPainter.lambda$0(AnnotationPainter.java:1075)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.783
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTError: No more handles)
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:171)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:135)
	at org.eclipse.jface.text.source.LineNumberRulerColumn.redraw(LineNumberRulerColumn.java:968)
	at org.eclipse.jface.internal.text.source.DiffPainter.redraw(DiffPainter.java:370)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.790
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTError: No more handles)
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:171)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:135)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.redraw(AnnotationRulerColumn.java:834)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.791
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTError: No more handles)
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:171)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:135)
	at org.eclipse.jface.text.source.OverviewRuler.redraw(OverviewRuler.java:907)
	at org.eclipse.jface.text.source.OverviewRuler.access$1(OverviewRuler.java:899)
	at org.eclipse.jface.text.source.OverviewRuler$InternalListener.textChanged(OverviewRuler.java:86)
	at org.eclipse.jface.text.TextViewer.updateTextListeners(TextViewer.java:2709)
	at org.eclipse.jface.text.TextViewer.invalidateTextPresentation(TextViewer.java:3353)
	at org.eclipse.jface.text.source.AnnotationPainter.invalidateTextPresentation(AnnotationPainter.java:970)
	at org.eclipse.jface.text.source.AnnotationPainter.updatePainting(AnnotationPainter.java:952)
	at org.eclipse.jface.text.source.AnnotationPainter.lambda$0(AnnotationPainter.java:1075)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.791
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTError: No more handles)
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:171)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:135)
	at org.eclipse.jface.text.source.OverviewRuler.redraw(OverviewRuler.java:907)
	at org.eclipse.jface.text.source.OverviewRuler.lambda$0(OverviewRuler.java:488)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.792
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTError: No more handles)
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:171)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:135)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.redraw(AnnotationRulerColumn.java:834)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more

!ENTRY org.eclipse.ui 4 0 2022-11-16 14:40:08.793
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTError: No more handles)
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:188)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3987)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4895)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Control.internal_new_GC(Control.java:1794)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:171)
	at org.eclipse.swt.graphics.GC.<init>(GC.java:135)
	at org.eclipse.jface.text.source.OverviewRuler.redraw(OverviewRuler.java:907)
	at org.eclipse.jface.text.source.OverviewRuler.access$1(OverviewRuler.java:899)
	at org.eclipse.jface.text.source.OverviewRuler$InternalListener.textChanged(OverviewRuler.java:86)
	at org.eclipse.jface.text.TextViewer.updateTextListeners(TextViewer.java:2709)
	at org.eclipse.jface.text.TextViewer.invalidateTextPresentation(TextViewer.java:3353)
	at org.eclipse.jface.text.source.AnnotationPainter.invalidateTextPresentation(AnnotationPainter.java:970)
	at org.eclipse.jface.text.source.AnnotationPainter.updatePainting(AnnotationPainter.java:952)
	at org.eclipse.jface.text.source.AnnotationPainter.lambda$0(AnnotationPainter.java:1075)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	... 23 more
!SESSION 2022-11-16 14:40:23.254 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2022-11-16 14:40:27.529
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.ui 2 0 2022-11-16 14:40:28.355
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-16 14:40:28.356
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-16 14:40:30.456
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-16 14:40:30.456
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3328db4f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4f9e9c21,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-16 14:40:35.584
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-17 13:21:39.624 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:21:46.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-17 13:21:49.697
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-17 13:21:49.697
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7151dd9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f596988,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-17 13:21:57.946
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-17 13:23:05.653 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:23:10.246
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-17 13:23:11.117
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-17 13:23:11.117
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3891db3a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a778943,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-17 13:23:15.413
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-17 13:29:47.884 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 13:29:50.837
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-17 13:29:51.710
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-17 13:29:51.710
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3891db3a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a778943,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-17 13:29:55.972
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2022-11-17 13:59:51.425
!MESSAGE Internal Error
!STACK 1
Java Model Exception: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2fapplet%2fpackage-summary.html
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:942)
	at org.eclipse.jdt.internal.core.PackageFragment.getAttachedJavadoc(PackageFragment.java:587)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:2127)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:505)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:93)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:78)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:63)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:590)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2fapplet%2fpackage-summary.html
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1974)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1969)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getChainedException(HttpURLConnection.java:1968)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1536)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:250)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:887)
	... 9 more
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2fapplet%2fpackage-summary.html
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1924)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:527)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:334)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:873)
	... 9 more
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2fapplet%2fpackage-summary.html
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1974)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1969)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getChainedException(HttpURLConnection.java:1968)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1536)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:250)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:887)
	at org.eclipse.jdt.internal.core.PackageFragment.getAttachedJavadoc(PackageFragment.java:587)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:2127)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:505)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:93)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:78)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:63)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:590)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2fapplet%2fpackage-summary.html
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1924)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:527)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:334)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:873)
	... 9 more
!SUBENTRY 1 org.eclipse.jdt.core 4 985 2022-11-17 13:59:51.426
!MESSAGE Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2fapplet%2fpackage-summary.html
!STACK 0
java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2fapplet%2fpackage-summary.html
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1974)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1969)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getChainedException(HttpURLConnection.java:1968)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1536)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:250)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:887)
	at org.eclipse.jdt.internal.core.PackageFragment.getAttachedJavadoc(PackageFragment.java:587)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:2127)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:505)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:93)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:78)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:63)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:590)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2fapplet%2fpackage-summary.html
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1924)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:527)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:334)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:873)
	... 9 more

!ENTRY org.eclipse.jdt.ui 4 10001 2022-11-17 13:59:51.656
!MESSAGE Internal Error
!STACK 1
Java Model Exception: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2futil%2fpackage-summary.html
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:942)
	at org.eclipse.jdt.internal.core.PackageFragment.getAttachedJavadoc(PackageFragment.java:587)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:2127)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:505)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:93)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:78)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:63)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:590)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2futil%2fpackage-summary.html
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1974)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1969)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getChainedException(HttpURLConnection.java:1968)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1536)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:250)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:887)
	... 9 more
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2futil%2fpackage-summary.html
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1924)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:527)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:334)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:873)
	... 9 more
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2futil%2fpackage-summary.html
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1974)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1969)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getChainedException(HttpURLConnection.java:1968)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1536)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:250)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:887)
	at org.eclipse.jdt.internal.core.PackageFragment.getAttachedJavadoc(PackageFragment.java:587)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:2127)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:505)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:93)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:78)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:63)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:590)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2futil%2fpackage-summary.html
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1924)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:527)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:334)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:873)
	... 9 more
!SUBENTRY 1 org.eclipse.jdt.core 4 985 2022-11-17 13:59:51.656
!MESSAGE Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2futil%2fpackage-summary.html
!STACK 0
java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2futil%2fpackage-summary.html
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1974)
	at java.base/sun.net.www.protocol.http.HttpURLConnection$10.run(HttpURLConnection.java:1969)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getChainedException(HttpURLConnection.java:1968)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1536)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:250)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:887)
	at org.eclipse.jdt.internal.core.PackageFragment.getAttachedJavadoc(PackageFragment.java:587)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:2127)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:505)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:93)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:78)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:63)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:590)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.IOException: Server returned HTTP response code: 500 for URL: https://docs.oracle.com/pls/rdman/handle404?X_ORCL_404path=%2fen%2fjava%2fjavase%2f11%2fdocs%2fapi%2fjava%2futil%2fpackage-summary.html
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1924)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:527)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:334)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:873)
	... 9 more
!SESSION 2022-11-17 15:12:40.545 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-17 15:12:46.885
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-17 15:12:47.777
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-17 15:12:47.777
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64b20d9c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc3f1a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-17 15:12:52.012
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-18 08:58:04.994 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.780
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.795
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-18 08:58:12.795
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-18 08:58:16.459
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-18 08:58:16.459
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc3f1a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7151dd9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-18 08:58:23.732
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-21 09:01:44.967 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 09:02:00.259
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-21 09:02:07.498
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-21 09:02:07.498
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2027d56f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44c54463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-21 09:02:26.591
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-21 12:04:20.998 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-21 12:04:24.247
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-21 12:04:25.193
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-21 12:04:25.193
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58a0f75b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b569858,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-21 12:04:29.457
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-22 08:50:32.824 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 08:50:45.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-22 08:50:53.341
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-22 08:50:53.341
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2027d56f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44c54463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-22 08:51:13.500
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-22 09:21:32.856 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-22 09:21:38.861
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-22 09:21:41.062
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-22 09:21:41.077
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41d8ac75,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e1d813a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-22 09:21:46.244
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-23 09:04:01.917 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 09:04:08.322
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-23 09:04:11.479
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-23 09:04:11.479
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@240e61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76efa2b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-23 09:04:18.395
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-23 11:10:14.557 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:10:42.163
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-23 11:10:44.500
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-23 11:10:44.500
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3545c913,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d00e30e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 4 2022-11-23 11:10:50.022
!MESSAGE Unable to create part
!STACK 1
org.eclipse.ui.PartInitException: Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3203)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1209)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:667)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.core.runtime.CoreException: Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1416)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2298)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	... 124 more
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2022-11-23 11:10:50.037
!MESSAGE Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1416)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2298)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1209)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:667)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2022-11-23 11:10:50.037
!MESSAGE Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.

!ENTRY org.eclipse.egit.ui 2 0 2022-11-23 11:10:50.975
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-23 11:11:12.477 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product -data C:\Java-Workspace\Java-Workspace -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:11:14.066
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-23 11:11:15.001
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-23 11:11:15.001
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1c80f8dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@51b2b3e6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 4 2022-11-23 11:11:17.080
!MESSAGE Unable to create part
!STACK 1
org.eclipse.ui.PartInitException: Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3203)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1209)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:667)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.core.runtime.CoreException: Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1416)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2298)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	... 124 more
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2022-11-23 11:11:17.080
!MESSAGE Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1416)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2298)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1209)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:667)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2022-11-23 11:11:17.096
!MESSAGE Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ArrayForeach.java'.

!ENTRY org.eclipse.egit.ui 2 0 2022-11-23 11:11:17.971
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 4 2022-11-23 11:11:26.706
!MESSAGE Unable to create part
!STACK 1
org.eclipse.ui.PartInitException: Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ObjectArrayRun.java'.
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3203)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4725)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3241)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1879)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:330)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4012)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3612)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.core.runtime.CoreException: Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ObjectArrayRun.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1416)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2353)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2351)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	... 83 more
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2022-11-23 11:11:26.707
!MESSAGE Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ObjectArrayRun.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ObjectArrayRun.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1416)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2353)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2351)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:736)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4725)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3241)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1879)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:330)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4012)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3612)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2022-11-23 11:11:26.707
!MESSAGE Cannot determine URI for '/07_ObjectArray/src/com/kh/chap02_objectArray/run/ObjectArrayRun.java'.
!SESSION 2022-11-23 11:13:15.589 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-23 11:13:19.939
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-23 11:13:20.830
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-23 11:13:20.830
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@365a4b9b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@240e61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-23 11:13:25.445
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-24 08:57:40.249 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2022-11-24 08:57:46.248
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-24 08:57:48.006
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-24 08:57:51.838
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-24 08:57:51.838
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4f9e9c21,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1390a43a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-24 08:57:57.078
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-11-24 10:25:21.297
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chpa01_beforeVsafter.after.model.vo;

			 //자식			 //부모
			 //후손			 //조상
			 //하위			 //상위
public class Desktop extends Product {

		private boolean allInOne;
		
		public Desktop() {
			
			
		}
		
		public Desktop(String brand, String pCode, String pName, int price, boolean allInOne) {
			//super :  부모클래스의 주소값을 보관하고 있음(즉, super. 으로 부모클래스에 접근이 가능함)
			
			// brand, pCode, pName,price를 부모클래스의 Product에 있는필드에 초기화(값을 대입) 하는 방법
			
			//해결방법1. 부모클래스의 필드를 자식까지는 접근가능하도록 접근제한자를 변경
			//			private => protected로 변경
			//super.brand = brand;
			//super.pCode = pCode;
			//super.pName = pName;
			//super.price = price;
			
			//해결방법2. 부모클래스에서 접근할 수 있는(public) setter메서드 활동
			//super.setBrand(brand);
			//super.setpCode(pCode);
			//super.setpName(pName);
			//super.setPrice(price);
			
			
			//해결방법3. 부모생성자 호출하기(배개변수있는 생성자 호출), 단 첫줄에 기술되어야 한다!
			super(brand, pCode, pName, price);
			this.allInOne-all
			
			
		}
		
		public void setAllInOne(boolean allInOne) {
			this.allInOne=allInOne;
		}
		
		public boolean getAllInOne() {
			return allInOne;
		}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-24 10:25:21.297
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-24 10:25:21.297
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-24 10:25:23.094
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.chpa01_beforeVsafter.after.model.vo;

			 //자식			 //부모
			 //후손			 //조상
			 //하위			 //상위
public class Desktop extends Product {

		private boolean allInOne;
		
		public Desktop() {
			
			
		}
		
		public Desktop(String brand, String pCode, String pName, int price, boolean allInOne) {
			//super :  부모클래스의 주소값을 보관하고 있음(즉, super. 으로 부모클래스에 접근이 가능함)
			
			// brand, pCode, pName,price를 부모클래스의 Product에 있는필드에 초기화(값을 대입) 하는 방법
			
			//해결방법1. 부모클래스의 필드를 자식까지는 접근가능하도록 접근제한자를 변경
			//			private => protected로 변경
			//super.brand = brand;
			//super.pCode = pCode;
			//super.pName = pName;
			//super.price = price;
			
			//해결방법2. 부모클래스에서 접근할 수 있는(public) setter메서드 활동
			//super.setBrand(brand);
			//super.setpCode(pCode);
			//super.setpName(pName);
			//super.setPrice(price);
			
			
			//해결방법3. 부모생성자 호출하기(배개변수있는 생성자 호출), 단 첫줄에 기술되어야 한다!
			super(brand, pCode, pName, price);
			this.allInOne-allInOne
			
			
		}
		
		public void setAllInOne(boolean allInOne) {
			this.allInOne=allInOne;
		}
		
		public boolean getAllInOne() {
			return allInOne;
		}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-11-24 10:25:23.094
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-11-24 10:25:23.094
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-11-25 09:37:54.748 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 09:38:23.652
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-25 09:38:27.200
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-25 09:38:27.200
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44c54463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64b20d9c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-25 09:38:33.797
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-25 15:16:19.450 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-25 15:16:24.277
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-25 15:16:26.371
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-25 15:16:26.371
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76efa2b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2027d56f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-25 15:16:30.698
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-28 09:03:22.955 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 09:03:33.490
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-28 09:03:37.739
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-28 09:03:37.739
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e1d813a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1964ef9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-28 09:03:46.253
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-28 12:30:16.665 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.17
java.vendor=Amazon.com Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-28 12:30:51.403
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-28 12:30:53.750
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-28 12:30:53.750
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2027d56f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44c54463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-28 12:30:58.212
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
